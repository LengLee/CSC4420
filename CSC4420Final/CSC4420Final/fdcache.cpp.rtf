{\rtf1\ansi\deff3\adeflang1025
{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fprq2\fcharset2 Symbol;}{\f2\fswiss\fprq2\fcharset0 Arial;}{\f3\froman\fprq2\fcharset0 Liberation Serif{\*\falt Times New Roman};}{\f4\fswiss\fprq2\fcharset0 Liberation Sans{\*\falt Arial};}{\f5\fmodern\fprq1\fcharset0 Liberation Mono{\*\falt Courier New};}{\f6\fnil\fprq2\fcharset0 Noto Sans CJK SC Regular;}{\f7\fmodern\fprq1\fcharset0 Nimbus Mono L{\*\falt Courier New};}{\f8\fnil\fprq2\fcharset0 FreeSans;}{\f9\fswiss\fprq0\fcharset128 FreeSans;}}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet{\s0\snext0\nowidctlpar\hyphpar0\cf0\dbch\af6\langfe2052\dbch\af8\afs24\alang1081\loch\f3\fs24\lang4105 Normal;}
{\s15\sbasedon0\snext16\sb240\sa120\keepn\dbch\af6\dbch\af8\afs28\loch\f4\fs28 Heading;}
{\s16\sbasedon0\snext16\sl288\slmult1\sb0\sa140 Text Body;}
{\s17\sbasedon16\snext17\sl288\slmult1\sb0\sa140\dbch\af9 List;}
{\s18\sbasedon0\snext18\sb120\sa120\noline\i\dbch\af9\afs24\ai\fs24 Caption;}
{\s19\sbasedon0\snext19\noline\dbch\af9 Index;}
{\s20\sbasedon0\snext20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20 Preformatted Text;}
}{\*\generator LibreOffice/5.1.6.2$Linux_X86_64 LibreOffice_project/10m0$Build-2}{\info{\creatim\yr0\mo0\dy0\hr0\min0}{\revtim\yr2018\mo4\dy29\hr15\min48}{\printim\yr0\mo0\dy0\hr0\min0}}\deftab709
\viewscale100
{\*\pgdsctbl
{\pgdsc0\pgdscuse451\pgwsxn12240\pghsxn15840\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\pgdscnxt0 Default Style;}}
\formshade\paperh15840\paperw12240\margl1134\margr1134\margt1134\margb1134\sectd\sbknone\sectunlocked1\pgndec\pgwsxn12240\pghsxn15840\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\ftnbj\ftnstart1\ftnrstcont\ftnnar\aenddoc\aftnrstcont\aftnstart1\aftnnrlc
{\*\ftnsep\chftnsep}\pgndec\pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
/*}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* s3fs - FUSE-based file system backed by Amazon S3}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
*}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* Copyright(C) 2007 Takeshi Nakatani <ggtakec.com>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
*}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* This program is free software; you can redistribute it and/or}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* modify it under the terms of the GNU General Public License}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* as published by the Free Software Foundation; either version 2}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* of the License, or (at your option) any later version.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
*}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* This program is distributed in the hope that it will be useful,}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* but WITHOUT ANY WARRANTY; without even the implied warranty of}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* GNU General Public License for more details.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
*}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* You should have received a copy of the GNU General Public License}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* along with this program; if not, write to the Free Software}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
*/}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <stdio.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <stdlib.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <sys/stat.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <sys/types.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <sys/time.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <sys/file.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <stdint.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <unistd.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <pthread.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <syslog.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <errno.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <string.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <assert.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <dirent.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <curl/curl.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <string>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <iostream>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <sstream>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <map>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <list>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <vector>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include "common.h"}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include "fdcache.h"}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include "s3fs.h"}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include "s3fs_util.h"}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include "string_util.h"}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include "curl.h"}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include <openssl/rc4.h>}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#include<openssl/md5.h> }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
using namespace std;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
void myrc4(int fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
size_t bsize = lseek(fd,0,SEEK_END); //define size of buffer}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
char *buf = (char *) malloc(bsize);     //allocate mem size of buffer}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
char *buffer = (char *) malloc(bsize);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
string p = "pass";  //string for the rc4 key}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
lseek(fd,0,SEEK_SET);   //seek back to beginning in fd }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
if(read(fd, buf, bsize) == -1)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
cout<<"Error reading \\n";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
\} //read the fd from 0 offset -> end into buf }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
RC4_KEY key;        //rc4 key}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
char passWord[p.length()];}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
strcpy(passWord, p.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
char digest_buff[MD5_DIGEST_LENGTH];}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
// use md5 function}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
MD5((const unsigned char*)passWord, strlen(passWord), (unsigned char*) &digest_buff);  }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
RC4_set_key(&key, strlen(digest_buff) ,(const unsigned char*) digest_buff); //set key}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
RC4(&key, bsize, (const unsigned char*)buf, (unsigned char*)buffer);  //perform rc4}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
lseek(fd,0,SEEK_SET);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
if(write(fd, buffer, bsize) == -1)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch
 }{\highlight7\rtlch \ltrch\loch
cout<<"Error writing \\n" ;  }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
\}//write the rc4 buffer back into fd}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
lseek(fd,0,SEEK_SET);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
free(buf);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\highlight7\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
free(buffer);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\highlight7\rtlch \ltrch\loch
\} }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// Symbols}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
static const int MAX_MULTIPART_CNT = 10 * 1000;  // S3 multipart max count}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// For cache directory top path}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#if defined(P_tmpdir)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#define TMPFILE_DIR_0PATH   P_tmpdir}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#else}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#define TMPFILE_DIR_0PATH   "/tmp"}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#endif}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// CacheFileStat class methods}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool CacheFileStat::MakeCacheFileStatPath(const char* path, string& sfile_path, bool is_create_dir)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// make stat dir top path( "/<cache_dir>/.<bucket_name>.stat" )}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
string top_path = FdManager::GetCacheDir();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
top_path       += "/.";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
top_path       += bucket;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
top_path       += ".stat";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(is_create_dir)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
int result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != (result = mkdirp(top_path + mydirname(path), 0777)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to create dir(%s) by errno(%d).", path, result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!path || '\\0' == path[0])\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
sfile_path = top_path;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
sfile_path = top_path + SAFESTRPTR(path);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool CacheFileStat::CheckCacheFileStatTopDir(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!FdManager::IsCacheDir())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// make stat dir top path( "/<cache_dir>/.<bucket_name>.stat" )}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
string top_path = FdManager::GetCacheDir();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
top_path       += "/.";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
top_path       += bucket;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
top_path       += ".stat";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return check_exist_dir_permission(top_path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool CacheFileStat::DeleteCacheFileStat(const char* path)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!path || '\\0' == path[0])\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// stat path}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
string sfile_path;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!CacheFileStat::MakeCacheFileStatPath(path, sfile_path, false))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to create cache stat file path(%s)", path);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 != unlink(sfile_path.c_str()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(ENOENT == errno)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_DBG("failed to delete file(%s): errno=%d", path, errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to delete file(%s): errno=%d", path, errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// If remove stat file directory, it should do before removing}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// file cache directory.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool CacheFileStat::DeleteCacheFileStatDirectory(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
string top_path = FdManager::GetCacheDir();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(top_path.empty() || bucket.empty())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
top_path       += "/.";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
top_path       += bucket;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
top_path       += ".stat";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return delete_files_in_dir(top_path.c_str(), true);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// CacheFileStat methods}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
CacheFileStat::CacheFileStat(const char* tpath) : path(""), fd(-1)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(tpath && '\\0' != tpath[0])\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
SetPath(tpath, true);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
CacheFileStat::~CacheFileStat()}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
Release();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool CacheFileStat::SetPath(const char* tpath, bool is_open)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!tpath || '\\0' == tpath[0])\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!Release())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// could not close old stat file.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(tpath)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
path = tpath;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!is_open)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return Open();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool CacheFileStat::Open(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 == path.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 != fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// already opened}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// stat path}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
string sfile_path;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!CacheFileStat::MakeCacheFileStatPath(path.c_str(), sfile_path, true))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to create cache stat file path(%s)", path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// open}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == (fd = open(sfile_path.c_str(), O_CREAT|O_RDWR, 0600)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to open cache stat file path(%s) - errno(%d)", path.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// lock}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == flock(fd, LOCK_EX))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to lock cache stat file(%s) - errno(%d)", path.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
close(fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
fd = -1;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// seek top}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 != lseek(fd, 0, SEEK_SET))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to lseek cache stat file(%s) - errno(%d)", path.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
flock(fd, LOCK_UN);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
close(fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
fd = -1;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("file locked(%s - %s)", path.c_str(), sfile_path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool CacheFileStat::Release(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// already release}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// unlock}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == flock(fd, LOCK_UN))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to unlock cache stat file(%s) - errno(%d)", path.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("file unlocked(%s)", path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == close(fd))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to close cache stat file(%s) - errno(%d)", path.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
fd = -1;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// PageList methods}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
void PageList::FreeList(fdpage_list_t& list)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(fdpage_list_t::iterator iter = list.begin(); iter != list.end(); iter = list.erase(iter))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
delete (*iter);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
list.clear();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
PageList::PageList(size_t size, bool is_loaded)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
Init(size, is_loaded);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
PageList::~PageList()}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
Clear();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
void PageList::Clear(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
PageList::FreeList(pages);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool PageList::Init(size_t size, bool is_loaded)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
Clear();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
fdpage* page = new fdpage(0, size, is_loaded);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
pages.push_back(page);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
size_t PageList::Size(void) const}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(pages.empty())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
fdpage_list_t::const_reverse_iterator riter = pages.rbegin();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return static_cast<size_t>((*riter)->next());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool PageList::Compress(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
bool is_first       = true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
bool is_last_loaded = false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(fdpage_list_t::iterator iter = pages.begin(); iter != pages.end(); )\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(is_first)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
is_first       = false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
is_last_loaded = (*iter)->loaded;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
++iter;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(is_last_loaded == (*iter)->loaded)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
fdpage_list_t::iterator biter = iter;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
--biter;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
(*biter)->bytes += (*iter)->bytes;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
delete *iter;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
iter = pages.erase(iter);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
is_last_loaded = (*iter)->loaded;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
++iter;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool PageList::Parse(off_t new_pos)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(fdpage_list_t::iterator iter = pages.begin(); iter != pages.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(new_pos == (*iter)->offset)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// nothing to do}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else if((*iter)->offset < new_pos && new_pos < (*iter)->next())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
fdpage* page    = new fdpage((*iter)->offset, static_cast<size_t>(new_pos - (*iter)->offset), (*iter)->loaded);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
(*iter)->bytes -= (new_pos - (*iter)->offset);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
(*iter)->offset = new_pos;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
pages.insert(iter, page);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool PageList::Resize(size_t size, bool is_loaded)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
size_t total = Size();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 == total)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
Init(size, is_loaded);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else if(total < size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// add new area}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
fdpage* page = new fdpage(static_cast<off_t>(total), (size - total), is_loaded);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
pages.push_back(page);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else if(size < total)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// cut area}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
for(fdpage_list_t::iterator iter = pages.begin(); iter != pages.end(); )\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(static_cast<size_t>((*iter)->next()) <= size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
++iter;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(size <= static_cast<size_t>((*iter)->offset))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
delete *iter;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
iter = pages.erase(iter);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
(*iter)->bytes = size - static_cast<size_t>((*iter)->offset);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{    // total == size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// nothing to do}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// compress area}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return Compress();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool PageList::IsPageLoaded(off_t start, size_t size) const}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(fdpage_list_t::const_iterator iter = pages.begin(); iter != pages.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if((*iter)->end() < start)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
continue;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(!(*iter)->loaded)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != size && static_cast<size_t>(start + size) <= static_cast<size_t>((*iter)->next()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool PageList::SetPageLoadedStatus(off_t start, size_t size, bool is_loaded, bool is_compress)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
size_t now_size = Size();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(now_size <= static_cast<size_t>(start))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(now_size < static_cast<size_t>(start))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// add}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
Resize(static_cast<size_t>(start), false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
Resize(static_cast<size_t>(start + size), is_loaded);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else if(now_size <= static_cast<size_t>(start + size))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// cut}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
Resize(static_cast<size_t>(start), false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// add}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
Resize(static_cast<size_t>(start + size), is_loaded);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// start-size are inner pages area}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// parse "start", and "start + size" position}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
Parse(start);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
Parse(start + size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// set loaded flag}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
for(fdpage_list_t::iterator iter = pages.begin(); iter != pages.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if((*iter)->end() < start)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
continue;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else if(static_cast<off_t>(start + size) <= (*iter)->offset)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
(*iter)->loaded = is_loaded;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// compress area}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return (is_compress ? Compress() : true);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool PageList::FindUnloadedPage(off_t start, off_t& resstart, size_t& ressize) const}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(fdpage_list_t::const_iterator iter = pages.begin(); iter != pages.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(start <= (*iter)->end())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(!(*iter)->loaded)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
resstart = (*iter)->offset;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
ressize  = (*iter)->bytes;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
size_t PageList::GetTotalUnloadedPageSize(off_t start, size_t size) const}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
size_t restsize = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
off_t  next     = static_cast<off_t>(start + size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(fdpage_list_t::const_iterator iter = pages.begin(); iter != pages.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if((*iter)->next() <= start)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
continue;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(next <= (*iter)->offset)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if((*iter)->loaded)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
continue;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
size_t tmpsize;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if((*iter)->offset <= start)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if((*iter)->next() <= next)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
tmpsize = static_cast<size_t>((*iter)->next() - start);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
tmpsize = static_cast<size_t>(next - start);                         // = size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if((*iter)->next() <= next)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
tmpsize = static_cast<size_t>((*iter)->next() - (*iter)->offset);   // = (*iter)->bytes}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
tmpsize = static_cast<size_t>(next - (*iter)->offset);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
restsize += tmpsize;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return restsize;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int PageList::GetUnloadedPages(fdpage_list_t& unloaded_list, off_t start, size_t size) const}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// If size is 0, it means loading to end.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 == size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(static_cast<size_t>(start) < Size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
size = static_cast<size_t>(Size() - start);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
off_t next = static_cast<off_t>(start + size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(fdpage_list_t::const_iterator iter = pages.begin(); iter != pages.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if((*iter)->next() <= start)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
continue;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(next <= (*iter)->offset)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if((*iter)->loaded)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
continue; // already loaded}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// page area}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
off_t  page_start = max((*iter)->offset, start);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
off_t  page_next  = min((*iter)->next(), next);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
size_t page_size  = static_cast<size_t>(page_next - page_start);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// add list}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
fdpage_list_t::reverse_iterator riter = unloaded_list.rbegin();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(riter != unloaded_list.rend() && (*riter)->next() == page_start)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// merge to before page}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
(*riter)->bytes += page_size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
fdpage* page = new fdpage(page_start, page_size, false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
unloaded_list.push_back(page);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return unloaded_list.size();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool PageList::Serialize(CacheFileStat& file, bool is_output)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!file.Open())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(is_output)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// put to file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
stringstream ssall;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
ssall << Size();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
for(fdpage_list_t::iterator iter = pages.begin(); iter != pages.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
ssall << "\\n" << (*iter)->offset << ":" << (*iter)->bytes << ":" << ((*iter)->loaded ? "1" : "0");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
string strall = ssall.str();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 >= pwrite(file.GetFd(), strall.c_str(), strall.length(), 0))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to write stats(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// loading from file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
struct stat st;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
memset(&st, 0, sizeof(struct stat));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(-1 == fstat(file.GetFd(), &st))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("fstat is failed. errno(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 >= st.st_size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// nothing}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
Init(0, false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
char* ptmp;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(NULL == (ptmp = (char*)calloc(st.st_size + 1, sizeof(char))))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_CRIT("could not allocate memory.");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_FUSE_EXIT();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// read from file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 >= pread(file.GetFd(), ptmp, st.st_size, 0))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to read stats(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
free(ptmp);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
string       oneline;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
stringstream ssall(ptmp);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// loaded}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
Clear();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// load(size)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(!getline(ssall, oneline, '\\n'))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to parse stats.");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
free(ptmp);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
size_t total = s3fs_strtoofft(oneline.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// load each part}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
bool is_err = false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
while(getline(ssall, oneline, '\\n'))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
string       part;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
stringstream ssparts(oneline);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// offset}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(!getline(ssparts, part, ':'))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
is_err = true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
off_t offset = s3fs_strtoofft(part.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(!getline(ssparts, part, ':'))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
is_err = true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
off_t size = s3fs_strtoofft(part.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// loaded}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(!getline(ssparts, part, ':'))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
is_err = true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
bool is_loaded = (1 == s3fs_strtoofft(part.c_str()) ? true : false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// add new area}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
SetPageLoadedStatus(offset, size, is_loaded);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
free(ptmp);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(is_err)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to parse stats.");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
Clear();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// check size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(total != Size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("different size(%jd - %jd).", (intmax_t)total, (intmax_t)Size());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
Clear();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
void PageList::Dump(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
int cnt = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("pages = \{");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(fdpage_list_t::iterator iter = pages.begin(); iter != pages.end(); ++iter, ++cnt)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_DBG("  [%08d] -> \{%014jd - %014zu : %s\}", cnt, (intmax_t)((*iter)->offset), (*iter)->bytes, (*iter)->loaded ? "true" : "false");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("\}");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// FdEntity class methods}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int FdEntity::FillFile(int fd, unsigned char byte, size_t size, off_t start)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
unsigned char bytes[1024 * 32];         // 32kb}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
memset(bytes, byte, min(sizeof(bytes), size));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(ssize_t total = 0, onewrote = 0; static_cast<size_t>(total) < size; total += onewrote)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(-1 == (onewrote = pwrite(fd, bytes, min(sizeof(bytes), (size - static_cast<size_t>(total))), start + total)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("pwrite failed. errno(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return -errno;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// FdEntity methods}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
FdEntity::FdEntity(const char* tpath, const char* cpath)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
: is_lock_init(false), refcnt(0), path(SAFESTRPTR(tpath)), cachepath(SAFESTRPTR(cpath)), mirrorpath(""),}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
fd(-1), pfile(NULL), is_modify(false), size_orgmeta(0), upload_id(""), mp_start(0), mp_size(0)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
try\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
pthread_mutexattr_t attr;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
pthread_mutexattr_init(&attr);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
pthread_mutexattr_settype(&attr, S3FS_MUTEX_RECURSIVE);   // recursive mutex}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
pthread_mutex_init(&fdent_lock, &attr);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
is_lock_init = true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}catch(exception& e)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_CRIT("failed to init mutex");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
FdEntity::~FdEntity()}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
Clear();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(is_lock_init)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
try\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
pthread_mutex_destroy(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}catch(exception& e)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_CRIT("failed to destroy mutex");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
is_lock_init = false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
void FdEntity::Clear(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 != fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != cachepath.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
CacheFileStat cfstat(path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(!pagelist.Serialize(cfstat, true))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_WARN("failed to save cache stat file(%s).", path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(pfile)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
fclose(pfile);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
pfile = NULL;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
fd = -1;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(!mirrorpath.empty())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(-1 == unlink(mirrorpath.c_str()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_WARN("failed to remove mirror cache file(%s) by errno(%d).", mirrorpath.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
mirrorpath.erase();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
pagelist.Init(0, false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
refcnt        = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
path          = "";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
cachepath     = "";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
is_modify     = false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
void FdEntity::Close(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("[path=%s][fd=%d][refcnt=%d]", path.c_str(), fd, (-1 != fd ? refcnt - 1 : refcnt));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 != fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 < refcnt)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
refcnt--;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 == refcnt)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 != cachepath.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
CacheFileStat cfstat(path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(!pagelist.Serialize(cfstat, true))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
S3FS_PRN_WARN("failed to save cache stat file(%s).", path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(pfile)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
fclose(pfile);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
pfile = NULL;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
fd = -1;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(!mirrorpath.empty())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(-1 == unlink(mirrorpath.c_str()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
S3FS_PRN_WARN("failed to remove mirror cache file(%s) by errno(%d).", mirrorpath.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
mirrorpath.erase();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int FdEntity::Dup()}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("[path=%s][fd=%d][refcnt=%d]", path.c_str(), fd, (-1 != fd ? refcnt + 1 : refcnt));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 != fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
refcnt++;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return fd;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// Open mirror file which is linked cache file.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int FdEntity::OpenMirrorFile(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(cachepath.empty())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("cache path is empty, why come here");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// make temporary directory}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
string bupdir;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!FdManager::MakeCachePath(NULL, bupdir, true, true))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("could not make bup cache directory path or create it.");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// create seed generating mirror file name}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
unsigned int seed = static_cast<unsigned int>(time(NULL));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
int urandom_fd;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 != (urandom_fd = open("/dev/urandom", O_RDONLY)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
unsigned int rand_data;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(sizeof(rand_data) == read(urandom_fd, &rand_data, sizeof(rand_data)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
seed ^= rand_data;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
close(urandom_fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// try to link mirror file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
while(true)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// make random(temp) file path}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// (do not care for threading, because allowed any value returned.)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
char         szfile[NAME_MAX + 1];}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
sprintf(szfile, "%x.tmp", rand_r(&seed));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
mirrorpath = bupdir + "/" + szfile;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// link mirror file to cache file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 == link(cachepath.c_str(), mirrorpath.c_str()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(EEXIST != errno)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("could not link mirror file(%s) to cache file(%s) by errno(%d).", mirrorpath.c_str(), cachepath.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return -errno;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
++seed;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// open mirror file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
int mirrorfd;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == (mirrorfd = open(mirrorpath.c_str(), O_RDWR)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("could not open mirror file(%s) by errno(%d).", mirrorpath.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -errno;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return mirrorfd;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int FdEntity::Open(headers_t* pmeta, ssize_t size, time_t time, bool no_fd_lock_wait)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("[path=%s][fd=%d][size=%jd][time=%jd]", path.c_str(), fd, (intmax_t)size, (intmax_t)time);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock, no_fd_lock_wait);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if (!auto_lock.isLockAcquired()) \{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// had to wait for fd lock, return}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 != fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// already opened, needs to increment refcnt.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
Dup();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// check only file size(do not need to save cfs and time.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 <= size && pagelist.Size() != static_cast<size_t>(size))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// truncate temporary file size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(-1 == ftruncate(fd, static_cast<size_t>(size)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to truncate temporary file(%d) by errno(%d).", fd, errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// resize page list}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(!pagelist.Resize(static_cast<size_t>(size), false))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to truncate temporary file information(%d).", fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// set original headers and set size.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
size_t new_size = (0 <= size ? static_cast<size_t>(size) : size_orgmeta);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(pmeta)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
orgmeta  = *pmeta;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
new_size = static_cast<size_t>(get_size(orgmeta));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(new_size < size_orgmeta)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
size_orgmeta = new_size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
bool  need_save_csf = false;  // need to save(reset) cache stat file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
bool  is_truncate   = false;  // need to truncate}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 != cachepath.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// using cache}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// open cache and cache stat file, load page info.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
CacheFileStat cfstat(path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// try to open cache file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(-1 != (fd = open(cachepath.c_str(), O_RDWR)) && pagelist.Serialize(cfstat, false))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// succeed to open cache file and to load stats data}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
struct stat st;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
memset(&st, 0, sizeof(struct stat));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(-1 == fstat(fd, &st))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("fstat is failed. errno(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
fd = -1;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return (0 == errno ? -EIO : -errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// check size, st_size, loading stat file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(-1 == size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(static_cast<size_t>(st.st_size) != pagelist.Size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
pagelist.Resize(st.st_size, false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
need_save_csf = true;     // need to update page info}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
size = static_cast<ssize_t>(st.st_size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(static_cast<size_t>(size) != pagelist.Size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
pagelist.Resize(static_cast<size_t>(size), false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
need_save_csf = true;     // need to update page info}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(static_cast<size_t>(size) != static_cast<size_t>(st.st_size))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
is_truncate = true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// could not open cache file or could not load stats data, so initialize it.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(-1 == (fd = open(cachepath.c_str(), O_CREAT|O_RDWR|O_TRUNC, 0600)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to open file(%s). errno(%d)", cachepath.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return (0 == errno ? -EIO : -errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
need_save_csf = true;       // need to update page info}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(-1 == size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
size = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
pagelist.Init(0, false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
pagelist.Resize(static_cast<size_t>(size), false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
is_truncate = true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// open mirror file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
int mirrorfd;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 >= (mirrorfd = OpenMirrorFile()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to open mirror file linked cache file(%s).", cachepath.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return (0 == mirrorfd ? -EIO : mirrorfd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// switch fd}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
close(fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
fd = mirrorfd;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// make file pointer(for being same tmpfile)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(NULL == (pfile = fdopen(fd, "wb")))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to get fileno(%s). errno(%d)", cachepath.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
close(fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
fd = -1;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return (0 == errno ? -EIO : -errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// not using cache}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// open temporary file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(NULL == (pfile = tmpfile()) || -1 ==(fd = fileno(pfile)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to open tmp file. err(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(pfile)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
fclose(pfile);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
pfile = NULL;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return (0 == errno ? -EIO : -errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(-1 == size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
size = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
pagelist.Init(0, false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
pagelist.Resize(static_cast<size_t>(size), false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
is_truncate = true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// truncate cache(tmp) file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(is_truncate)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != ftruncate(fd, static_cast<off_t>(size)) || 0 != fsync(fd))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("ftruncate(%s) or fsync returned err(%d)", cachepath.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
fclose(pfile);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
pfile = NULL;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
fd    = -1;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return (0 == errno ? -EIO : -errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// reset cache stat file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(need_save_csf)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
CacheFileStat cfstat(path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(!pagelist.Serialize(cfstat, true))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_WARN("failed to save cache stat file(%s), but continue...", path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// init internal data}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
refcnt    = 1;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
is_modify = false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// set original headers and size in it.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(pmeta)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
orgmeta      = *pmeta;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
size_orgmeta = static_cast<size_t>(get_size(orgmeta));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
orgmeta.clear();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
size_orgmeta = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// set mtime(set "x-amz-meta-mtime" in orgmeta)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 != time)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != SetMtime(time))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to set mtime. errno(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
fclose(pfile);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
pfile = NULL;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
fd    = -1;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return (0 == errno ? -EIO : -errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// This method is called from only nocopyapi functions.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// So we do not check disk space for this option mode, if there is no enough}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// disk space this method will be failed.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdEntity::OpenAndLoadAll(headers_t* pmeta, size_t* size, bool force_load)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
int result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_INFO3("[path=%s][fd=%d]", path.c_str(), fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != Open(pmeta))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(force_load)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
SetAllStatusUnloaded();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// TODO: possibly do background for delay loading}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 != (result = Load()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("could not download, result(%d)", result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(is_modify)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
is_modify = false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
*size = pagelist.Size();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdEntity::GetStats(struct stat& st)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
memset(&st, 0, sizeof(struct stat)); }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == fstat(fd, &st))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("fstat failed. errno(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int FdEntity::SetMtime(time_t time)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_INFO3("[path=%s][fd=%d][time=%jd]", path.c_str(), fd, (intmax_t)time);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == time)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 != fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
struct timeval tv[2];}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
tv[0].tv_sec = time;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
tv[0].tv_usec= 0L;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
tv[1].tv_sec = tv[0].tv_sec;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
tv[1].tv_usec= 0L;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(-1 == futimes(fd, tv))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("futimes failed. errno(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return -errno;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else if(0 < cachepath.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// not opened file yet.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
struct utimbuf n_mtime;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
n_mtime.modtime = time;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
n_mtime.actime  = time;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(-1 == utime(cachepath.c_str(), &n_mtime))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("utime failed. errno(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return -errno;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
orgmeta["x-amz-meta-mtime"] = str(time);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdEntity::UpdateMtime(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
struct stat st;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!GetStats(st))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
orgmeta["x-amz-meta-mtime"] = str(st.st_mtime);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdEntity::GetSize(size_t& size)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
size = pagelist.Size();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdEntity::SetMode(mode_t mode)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
orgmeta["x-amz-meta-mode"] = str(mode);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdEntity::SetUId(uid_t uid)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
orgmeta["x-amz-meta-uid"] = str(uid);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdEntity::SetGId(gid_t gid)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
orgmeta["x-amz-meta-gid"] = str(gid);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdEntity::SetContentType(const char* path)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!path)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
orgmeta["Content-Type"] = S3fsCurl::LookupMimeType(string(path));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdEntity::SetAllStatus(bool is_loaded)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_INFO3("[path=%s][fd=%d][%s]", path.c_str(), fd, is_loaded ? "loaded" : "unloaded");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// this method is only internal use, and calling after locking.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// so do not lock now.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
//AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// get file size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
struct stat st;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
memset(&st, 0, sizeof(struct stat));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == fstat(fd, &st))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("fstat is failed. errno(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// Reinit}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
pagelist.Init(st.st_size, is_loaded);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
/* }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
My XOR decryption }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
void decrypt(int fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
size_t bsize = lseek(fd,0,SEEK_END); //define size of buffer}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
char *buf = (char *) malloc(bsize);     //allocate mem size of buffer}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
char *buffer = (char *) malloc(bsize);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
lseek(fd,0,SEEK_SET); }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
if(read(fd, buf, bsize) == -1)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
cout<<"Error reading \\n";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\} //read the fd from 0 offset -> end into buf }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
for(unsigned int i = 0; i <= bsize; i++)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
buffer[i] = (buf[i] ^ 'v');     //xor buf}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
if(ftruncate(fd,0)==-1)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\tab cout<<"Truncate failed \\n";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
lseek(fd,0,SEEK_SET);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
if(write(fd, buffer, bsize) == -1)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
cout<<"Error writing \\n" ;  }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}//write the xor buf back into fd}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
free(buf);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
free(buffer);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\} }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
*/}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int FdEntity::Load(off_t start, size_t size)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("[path=%s][fd=%d][offset=%jd][size=%jd]", path.c_str(), fd, (intmax_t)start, (intmax_t)size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -EBADF;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\tab }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
int result = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\tab }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// check loaded area & load}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
fdpage_list_t unloaded_list;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 < pagelist.GetUnloadedPages(unloaded_list, start, size))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
for(fdpage_list_t::iterator iter = unloaded_list.begin(); iter != unloaded_list.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 != size && static_cast<size_t>(start + size) <= static_cast<size_t>((*iter)->offset))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// reached end}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// check loading size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
size_t need_load_size = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(static_cast<size_t>((*iter)->offset) < size_orgmeta)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// original file size(on S3) is smaller than request.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
need_load_size = (static_cast<size_t>((*iter)->next()) <= size_orgmeta ? (*iter)->bytes : (size_orgmeta - (*iter)->offset));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
size_t over_size = (*iter)->bytes - need_load_size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// download}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(static_cast<size_t>(2 * S3fsCurl::GetMultipartSize()) <= need_load_size && !nomultipart)\{ // default 20MB}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// parallel request}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// Additional time is needed for large files}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
time_t backup = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(120 > S3fsCurl::GetReadwriteTimeout())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
backup = S3fsCurl::SetReadwriteTimeout(120);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
result = S3fsCurl::ParallelGetObjectRequest(path.c_str(), fd, (*iter)->offset, need_load_size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(0 != backup)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
S3fsCurl::SetReadwriteTimeout(backup);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// single request}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(0 < need_load_size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
S3fsCurl s3fscurl;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
result = s3fscurl.GetObjectRequest(path.c_str(), fd, (*iter)->offset, need_load_size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
result = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 != result)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\tab }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// initialize for the area of over original size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 < over_size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(0 != (result = FdEntity::FillFile(fd, 0, over_size, (*iter)->offset + need_load_size)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to fill rest bytes for fd(%d). errno(%d)", fd, result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// set modify flag}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
is_modify = false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\tab //decrypt(fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\tab myrc4(fd); }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\tab }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// Set loaded flag}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
pagelist.SetPageLoadedStatus((*iter)->offset, static_cast<off_t>((*iter)->bytes), true); }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
PageList::FreeList(unloaded_list);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\tab }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// At no disk space for caching object.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// This method is downloading by dividing an object of the specified range}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// and uploading by multipart after finishing downloading it.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// [NOTICE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// Need to lock before calling this method.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int FdEntity::NoCacheLoadAndPost(off_t start, size_t size)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
int result = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_INFO3("[path=%s][fd=%d][offset=%jd][size=%jd]", path.c_str(), fd, (intmax_t)start, (intmax_t)size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -EBADF;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// This method calling means that the cache file is never used no more.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 != cachepath.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// remove cache files(and cache stat file)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
FdManager::DeleteCacheFile(path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// cache file path does not use no more.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
cachepath.erase();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
mirrorpath.erase();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// Change entity key in manager mapping}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
FdManager::get()->ChangeEntityToTempPath(this, path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// open temporary file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
FILE* ptmpfp;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
int   tmpfd;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(NULL == (ptmpfp = tmpfile()) || -1 ==(tmpfd = fileno(ptmpfp)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to open tmp file. err(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(ptmpfp)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
fclose(ptmpfp);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return (0 == errno ? -EIO : -errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// loop uploading by multipart}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(fdpage_list_t::iterator iter = pagelist.pages.begin(); iter != pagelist.pages.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if((*iter)->end() < start)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
continue;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != size && static_cast<size_t>(start + size) <= static_cast<size_t>((*iter)->offset))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// download each multipart size(default 10MB) in unit}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
for(size_t oneread = 0, totalread = ((*iter)->offset < start ? start : 0); totalread < (*iter)->bytes; totalread += oneread)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
int   upload_fd = fd;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
off_t offset    = (*iter)->offset + totalread;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
oneread         = min(((*iter)->bytes - totalread), static_cast<size_t>(S3fsCurl::GetMultipartSize()));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// check rest size is over minimum part size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// If the final part size is smaller than 5MB, it is not allowed by S3 API.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// For this case, if the previous part of the final part is not over 5GB,}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// we incorporate the final part to the previous part. If the previous part}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// is over 5GB, we want to even out the last part and the previous part.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(((*iter)->bytes - totalread - oneread) < MIN_MULTIPART_SIZE)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(FIVE_GB < ((*iter)->bytes - totalread))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
oneread = ((*iter)->bytes - totalread) / 2;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
oneread = ((*iter)->bytes - totalread);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(!(*iter)->loaded)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// loading or initializing}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
upload_fd = tmpfd;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// load offset & size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
size_t need_load_size = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(size_orgmeta <= static_cast<size_t>(offset))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
// all area is over of original size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
need_load_size      = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
if(size_orgmeta < (offset + oneread))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
            }{\rtlch \ltrch\loch
// original file size(on S3) is smaller than request.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
            }{\rtlch \ltrch\loch
need_load_size    = size_orgmeta - offset;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
            }{\rtlch \ltrch\loch
need_load_size    = oneread;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
size_t over_size      = oneread - need_load_size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// truncate file to zero and set length to part offset + size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// after this, file length is (offset + size), but file does not use any disk space.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(-1 == ftruncate(tmpfd, 0) || -1 == ftruncate(tmpfd, (offset + oneread)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to truncate temporary file(%d).", tmpfd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
result = -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// single area get request}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(0 < need_load_size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
S3fsCurl s3fscurl;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
if(0 != (result = s3fscurl.GetObjectRequest(path.c_str(), tmpfd, offset, oneread)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
            }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to get object(start=%zd, size=%zu) for file(%d).", offset, oneread, tmpfd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
            }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// initialize fd without loading}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(0 < over_size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
if(0 != (result = FdEntity::FillFile(tmpfd, 0, over_size, offset + need_load_size)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
            }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to fill rest bytes for fd(%d). errno(%d)", tmpfd, result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
            }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
// set modify flag}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
is_modify = false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// already loaded area}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// single area upload by multipart post}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 != (result = NoCacheMultipartPost(upload_fd, offset, oneread)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to multipart post(start=%zd, size=%zu) for file(%d).", offset, oneread, upload_fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != result)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// set loaded flag}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(!(*iter)->loaded)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if((*iter)->offset < start)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
fdpage* page    = new fdpage((*iter)->offset, static_cast<size_t>(start - (*iter)->offset), (*iter)->loaded);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
(*iter)->bytes -= (start - (*iter)->offset);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
(*iter)->offset = start;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
pagelist.pages.insert(iter, page);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 != size && static_cast<size_t>(start + size) < static_cast<size_t>((*iter)->next()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
fdpage* page    = new fdpage((*iter)->offset, static_cast<size_t>((start + size) - (*iter)->offset), true);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
(*iter)->bytes -= static_cast<size_t>((start + size) - (*iter)->offset);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
(*iter)->offset = start + size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
pagelist.pages.insert(iter, page);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
(*iter)->loaded = true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 == result)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// compress pagelist}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
pagelist.Compress();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// fd data do empty}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(-1 == ftruncate(fd, 0))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to truncate file(%d), but continue...", fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// close temporary}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
fclose(ptmpfp);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// At no disk space for caching object.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// This method is starting multipart uploading.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int FdEntity::NoCachePreMultipartPost(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// initialize multipart upload values}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
upload_id.erase();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
etaglist.clear();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3fsCurl s3fscurl(true);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
int      result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 != (result = s3fscurl.PreMultipartPostRequest(path.c_str(), orgmeta, upload_id, false)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
s3fscurl.DestroyCurlHandle();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// At no disk space for caching object.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// This method is uploading one part of multipart.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int FdEntity::NoCacheMultipartPost(int tgfd, off_t start, size_t size)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == tgfd || upload_id.empty())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("Need to initialize for multipart post.");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3fsCurl s3fscurl(true);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return s3fscurl.MultipartUploadRequest(upload_id, path.c_str(), tgfd, start, size, etaglist);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// At no disk space for caching object.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// This method is finishing multipart uploading.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int FdEntity::NoCacheCompleteMultipartPost(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(upload_id.empty() || etaglist.empty())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("There is no upload id or etag list.");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3fsCurl s3fscurl(true);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
int      result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 != (result = s3fscurl.CompleteMultipartPostRequest(path.c_str(), upload_id, etaglist)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
s3fscurl.DestroyCurlHandle();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// reset values}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
upload_id.erase();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
etaglist.clear();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
mp_start = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
mp_size  = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
/* }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
MY XOR Encryption}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
void bxor(int fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
size_t bsize = lseek(fd,0,SEEK_END); //define size of buffer}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
char *buf = (char *) malloc(bsize);     //allocate mem size of buffer}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
char *buffer = (char *) malloc(bsize);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
lseek(fd,0,SEEK_SET); }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
if(read(fd, buf, bsize) == -1)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
cout<<"Error reading \\n";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\} //read the fd from 0 offset -> end into buf }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
for(unsigned int i = 0; i <= bsize; i++)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
buffer[i] = (buf[i] ^ 'v');     //xor buf}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
if(ftruncate(fd,0)==-1)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\tab cout<<"Truncate failed\\n";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
lseek(fd,0,SEEK_SET);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
if(write(fd, buffer, bsize) == -1)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
 }{\rtlch \ltrch\loch
cout<<"Error writing \\n" ;  }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}//write the xor buf back into fd}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
free(buf);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
free(buffer);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\} }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
*/ }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int FdEntity::RowFlush(const char* tpath, bool force_sync)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
int result = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
   }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_INFO3("[tpath=%s][path=%s][fd=%d]", SAFESTRPTR(tpath), path.c_str(), fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -EBADF;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\tab //bxor(fd); }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\tab myrc4(fd); }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!force_sync && !is_modify)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// nothing to update.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// If there is no loading all of the area, loading all area.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
size_t restsize = pagelist.GetTotalUnloadedPageSize();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 < restsize)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 == upload_id.length())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// check disk space}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(ReserveDiskSpace(restsize))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// enough disk space}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// Load all uninitialized area}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
result = Load();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
FdManager::get()->FreeReservedDiskSpace(restsize);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(0 != result)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to upload all area(errno=%d)", result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
return static_cast<ssize_t>(result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// no enough disk space}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// upload all by multipart uploading}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(0 != (result = NoCacheLoadAndPost()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to upload all area by multipart uploading(errno=%d)", result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
return static_cast<ssize_t>(result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// already start multipart uploading}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 == upload_id.length())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// normal uploading}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
/*}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
* Make decision to do multi upload (or not) based upon file size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
* }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
* According to the AWS spec:}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
*  - 1 to 10,000 parts are allowed}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
*  - minimum size of parts is 5MB (expect for the last part)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
* }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
* For our application, we will define minimum part size to be 10MB (10 * 2^20 Bytes)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
* minimum file size will be 64 GB - 2 ** 36 }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
* }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
* Initially uploads will be done serially}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
* }
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
* If file is > 20MB, then multipart will kick in}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
     }{\rtlch \ltrch\loch
*/}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(pagelist.Size() > static_cast<size_t>(MAX_MULTIPART_CNT * S3fsCurl::GetMultipartSize()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// close f ?}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return -ENOTSUP;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// seek to head of file.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != lseek(fd, 0, SEEK_SET))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("lseek error(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return -errno;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// backup upload file size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
struct stat st;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
memset(&st, 0, sizeof(struct stat));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(-1 == fstat(fd, &st))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("fstat is failed by errno(%d), but continue...", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(pagelist.Size() >= static_cast<size_t>(2 * S3fsCurl::GetMultipartSize()) && !nomultipart)\{ // default 20MB}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// Additional time is needed for large files}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
time_t backup = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(120 > S3fsCurl::GetReadwriteTimeout())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
backup = S3fsCurl::SetReadwriteTimeout(120);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
result = S3fsCurl::ParallelMultipartUploadRequest(tpath ? tpath : path.c_str(), orgmeta, fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 != backup)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3fsCurl::SetReadwriteTimeout(backup);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3fsCurl s3fscurl(true);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
result = s3fscurl.PutRequest(tpath ? tpath : path.c_str(), orgmeta, fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// seek to head of file.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 == result && 0 != lseek(fd, 0, SEEK_SET))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("lseek error(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return -errno;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// reset uploaded file size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
size_orgmeta = static_cast<size_t>(st.st_size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// upload rest data}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 < mp_size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 != (result = NoCacheMultipartPost(fd, mp_start, mp_size)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to multipart post(start=%zd, size=%zu) for file(%d).", mp_start, mp_size, fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
mp_start = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
mp_size  = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// complete multipart uploading.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != (result = NoCacheCompleteMultipartPost()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to complete(finish) multipart post for file(%d).", fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// truncate file to zero}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(-1 == ftruncate(fd, 0))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// So the file has already been removed, skip error.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to truncate file(%d) to zero, but continue...", fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 == result)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
is_modify = false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// [NOTICE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// Need to lock before calling this method.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdEntity::ReserveDiskSpace(size_t size)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(FdManager::get()->ReserveDiskSpace(size))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!is_modify)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// try to clear all cache for this fd.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
pagelist.Init(pagelist.Size(), false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(-1 == ftruncate(fd, 0) || -1 == ftruncate(fd, pagelist.Size()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to truncate temporary file(%d).", fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(FdManager::get()->ReserveDiskSpace(size))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
FdManager::get()->CleanupCacheDir();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return FdManager::get()->ReserveDiskSpace(size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
ssize_t FdEntity::Read(char* bytes, off_t start, size_t size, bool force_load)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("[path=%s][fd=%d][offset=%jd][size=%zu]", path.c_str(), fd, (intmax_t)start, size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -EBADF;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(force_load)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
pagelist.SetPageLoadedStatus(start, size, false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
ssize_t rsize;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// check disk space}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 < pagelist.GetTotalUnloadedPageSize(start, size))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// load size(for prefetch)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
size_t load_size = size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(static_cast<size_t>(start + size) < pagelist.Size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
size_t prefetch_max_size = max(size, static_cast<size_t>(S3fsCurl::GetMultipartSize() * S3fsCurl::GetMaxParallelCount()));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(static_cast<size_t>(start + prefetch_max_size) < pagelist.Size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
load_size = prefetch_max_size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
load_size = static_cast<size_t>(pagelist.Size() - start);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(!ReserveDiskSpace(load_size))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_WARN("could not reserve disk space for pre-fetch download");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
load_size = size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(!ReserveDiskSpace(load_size))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("could not reserve disk space for pre-fetch download");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return -ENOSPC;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// Loading}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
int result = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 < size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
result = Load(start, load_size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
FdManager::get()->FreeReservedDiskSpace(load_size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != result)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("could not download. start(%jd), size(%zu), errno(%d)", (intmax_t)start, size, result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// Reading}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == (rsize = pread(fd, bytes, size, start)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("pread failed. errno(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -errno;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return rsize;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
ssize_t FdEntity::Write(const char* bytes, off_t start, size_t size)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("[path=%s][fd=%d][offset=%jd][size=%zu]", path.c_str(), fd, (intmax_t)start, size);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == fd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -EBADF;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// check if not enough disk space left BEFORE locking fd}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(FdManager::IsCacheDir() && !FdManager::IsSafeDiskSpace(NULL, size))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
FdManager::get()->CleanupCacheDir();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// check file size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(pagelist.Size() < static_cast<size_t>(start))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// grow file size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(-1 == ftruncate(fd, static_cast<size_t>(start)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to truncate temporary file(%d).", fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// add new area}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
pagelist.SetPageLoadedStatus(static_cast<off_t>(pagelist.Size()), static_cast<size_t>(start) - pagelist.Size(), false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
int     result = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
ssize_t wsize;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 == upload_id.length())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// check disk space}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
size_t restsize = pagelist.GetTotalUnloadedPageSize(0, start) + size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(ReserveDiskSpace(restsize))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// enough disk space}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// Load uninitialized area which starts from 0 to (start + size) before writing.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 < start)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
result = Load(0, static_cast<size_t>(start));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
FdManager::get()->FreeReservedDiskSpace(restsize);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 != result)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to load uninitialized area before writing(errno=%d)", result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return static_cast<ssize_t>(result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// no enough disk space}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 != (result = NoCachePreMultipartPost()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to switch multipart uploading with no cache(errno=%d)", result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return static_cast<ssize_t>(result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// start multipart uploading}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 != (result = NoCacheLoadAndPost(0, start)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to load uninitialized area and multipart uploading it(errno=%d)", result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return static_cast<ssize_t>(result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
mp_start = start;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
mp_size  = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// already start multipart uploading}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// Writing}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == (wsize = pwrite(fd, bytes, size, start)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("pwrite failed. errno(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -errno;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!is_modify)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
is_modify = true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 < wsize)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
pagelist.SetPageLoadedStatus(start, static_cast<size_t>(wsize), true);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// check multipart uploading}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 < upload_id.length())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
mp_size += static_cast<size_t>(wsize);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(static_cast<size_t>(S3fsCurl::GetMultipartSize()) <= mp_size)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// over one multipart size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 != (result = NoCacheMultipartPost(fd, mp_start, mp_size)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to multipart post(start=%zd, size=%zu) for file(%d).", mp_start, mp_size, fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// truncate file to zero and set length to part offset + size}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// after this, file length is (offset + size), but file does not use any disk space.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(-1 == ftruncate(fd, 0) || -1 == ftruncate(fd, (mp_start + mp_size)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to truncate file(%d).", fd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
mp_start += mp_size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
mp_size   = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return wsize;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
void FdEntity::CleanupCache()}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&fdent_lock, true);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if (!auto_lock.isLockAcquired()) \{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if (is_modify) \{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// cache is not commited to s3, cannot cleanup}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
FdManager::DeleteCacheFile(path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// FdManager symbol}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// NOCACHE_PATH_PREFIX symbol needs for not using cache mode.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// Now s3fs I/F functions in s3fs.cpp has left the processing}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// to FdManager and FdEntity class. FdManager class manages}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// the list of local file stat and file descriptor in conjunction}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// with the FdEntity class.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// When s3fs is not using local cache, it means FdManager must}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// return new temporary file descriptor at each opening it.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// Then FdManager caches fd by key which is dummy file path}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// instead of real file path.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// This process may not be complete, but it is easy way can}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// be realized.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
#define NOCACHE_PATH_PREFIX_FORM    " __S3FS_UNEXISTED_PATH_%lx__ / "      // important space words for simply}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// FdManager class variable}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
FdManager       FdManager::singleton;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
pthread_mutex_t FdManager::fd_manager_lock;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
pthread_mutex_t FdManager::cache_cleanup_lock;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
pthread_mutex_t FdManager::reserved_diskspace_lock;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool            FdManager::is_lock_init(false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
string          FdManager::cache_dir("");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool            FdManager::check_cache_dir_exist(false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
size_t          FdManager::free_disk_space = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// FdManager class methods}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdManager::SetCacheDir(const char* dir)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!dir || '\\0' == dir[0])\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
cache_dir = "";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
cache_dir = dir;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdManager::DeleteCacheDirectory(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 == FdManager::cache_dir.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
string cache_dir;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!FdManager::MakeCachePath(NULL, cache_dir, false))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return delete_files_in_dir(cache_dir.c_str(), true);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
int FdManager::DeleteCacheFile(const char* path)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_INFO3("[path=%s]", SAFESTRPTR(path));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!path)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 == FdManager::cache_dir.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
string cache_path = "";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!FdManager::MakeCachePath(path, cache_path, false))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
int result = 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 != unlink(cache_path.c_str()))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(ENOENT == errno)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_DBG("failed to delete file(%s): errno=%d", path, errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to delete file(%s): errno=%d", path, errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
result = -errno;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!CacheFileStat::DeleteCacheFileStat(path))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(ENOENT == errno)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_DBG("failed to delete stat file(%s): errno=%d", path, errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to delete stat file(%s): errno=%d", path, errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != errno)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
result = -errno;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
result = -EIO;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdManager::MakeCachePath(const char* path, string& cache_path, bool is_create_dir, bool is_mirror_path)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 == FdManager::cache_dir.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
cache_path = "";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
string resolved_path(FdManager::cache_dir);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!is_mirror_path)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
resolved_path += "/";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
resolved_path += bucket;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
resolved_path += "/.";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
resolved_path += bucket;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
resolved_path += ".mirror";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(is_create_dir)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
int result;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != (result = mkdirp(resolved_path + mydirname(path), 0777)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to create dir(%s) by errno(%d).", path, result);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!path || '\\0' == path[0])\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
cache_path = resolved_path;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
cache_path = resolved_path + SAFESTRPTR(path);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdManager::CheckCacheTopDir(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 == FdManager::cache_dir.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
string toppath(FdManager::cache_dir + "/" + bucket);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return check_exist_dir_permission(toppath.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdManager::MakeRandomTempPath(const char* path, string& tmppath)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
char szBuff[64];}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
sprintf(szBuff, NOCACHE_PATH_PREFIX_FORM, random());     // worry for performance, but maybe don't worry.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
tmppath  = szBuff;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
tmppath += path ? path : "";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdManager::SetCheckCacheDirExist(bool is_check)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
bool old = FdManager::check_cache_dir_exist;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
FdManager::check_cache_dir_exist = is_check;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return old;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdManager::CheckCacheDirExist(void)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!FdManager::check_cache_dir_exist)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 == FdManager::cache_dir.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// check the directory}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
struct stat st;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 != stat(cache_dir.c_str(), &st))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("could not access to cache directory(%s) by errno(%d).", cache_dir.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!S_ISDIR(st.st_mode))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("the cache directory(%s) is not directory.", cache_dir.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
size_t FdManager::SetEnsureFreeDiskSpace(size_t size)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
size_t old = FdManager::free_disk_space;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
FdManager::free_disk_space = size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return old;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
uint64_t FdManager::GetFreeDiskSpace(const char* path)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
struct statvfs vfsbuf;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
string         ctoppath;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 < FdManager::cache_dir.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
ctoppath = FdManager::cache_dir + "/";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
ctoppath = get_exist_directory_path(ctoppath);\tab // existed directory}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(ctoppath != "/")\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
ctoppath += "/";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
ctoppath = TMPFILE_DIR_0PATH "/";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(path && '\\0' != *path)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
ctoppath += path;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
ctoppath += ".";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 == statvfs(ctoppath.c_str(), &vfsbuf))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("could not get vfs stat by errno(%d)", errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return 0;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return (vfsbuf.f_bavail * vfsbuf.f_frsize);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdManager::IsSafeDiskSpace(const char* path, size_t size)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
uint64_t fsize = FdManager::GetFreeDiskSpace(path);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return ((size + FdManager::GetEnsureFreeDiskSpace()) <= fsize);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
// FdManager methods}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
//------------------------------------------------}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
FdManager::FdManager()}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(this == FdManager::get())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
try\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
pthread_mutex_init(&FdManager::fd_manager_lock, NULL);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
pthread_mutex_init(&FdManager::cache_cleanup_lock, NULL);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
pthread_mutex_init(&FdManager::reserved_diskspace_lock, NULL);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
FdManager::is_lock_init = true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}catch(exception& e)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
FdManager::is_lock_init = false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_CRIT("failed to init mutex");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
assert(false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
FdManager::~FdManager()}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(this == FdManager::get())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
for(fdent_map_t::iterator iter = fent.begin(); fent.end() != iter; ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
FdEntity* ent = (*iter).second;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
delete ent;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
fent.clear();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(FdManager::is_lock_init)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
try\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
pthread_mutex_destroy(&FdManager::fd_manager_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
pthread_mutex_destroy(&FdManager::cache_cleanup_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
pthread_mutex_destroy(&FdManager::reserved_diskspace_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}catch(exception& e)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_CRIT("failed to init mutex");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
FdManager::is_lock_init = false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
assert(false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
FdEntity* FdManager::GetFdEntity(const char* path, int existfd)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_INFO3("[path=%s][fd=%d]", SAFESTRPTR(path), existfd);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!path || '\\0' == path[0])\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return NULL;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&FdManager::fd_manager_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
fdent_map_t::iterator iter = fent.find(string(path));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(fent.end() != iter && (-1 == existfd || (*iter).second->GetFd() == existfd))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return (*iter).second;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(-1 != existfd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
for(iter = fent.begin(); iter != fent.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if((*iter).second && (*iter).second->GetFd() == existfd)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// found opened fd in map}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(0 == strcmp((*iter).second->GetPath(), path))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
return (*iter).second;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// found fd, but it is used another file(file descriptor is recycled)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// so returns NULL.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return NULL;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
FdEntity* FdManager::Open(const char* path, headers_t* pmeta, ssize_t size, time_t time, bool force_tmpfile, bool is_create, bool no_fd_lock_wait)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("[path=%s][size=%jd][time=%jd]", SAFESTRPTR(path), (intmax_t)size, (intmax_t)time);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!path || '\\0' == path[0])\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return NULL;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
FdEntity* ent;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
AutoLock auto_lock(&FdManager::fd_manager_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// search in mapping by key(path)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
fdent_map_t::iterator iter = fent.find(string(path));}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(fent.end() == iter && !force_tmpfile && !FdManager::IsCacheDir())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// If the cache directory is not specified, s3fs opens a temporary file}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// when the file is opened.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// Then if it could not find a entity in map for the file, s3fs should}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// search a entity in all which opened the temporary file.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
for(iter = fent.begin(); iter != fent.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if((*iter).second && (*iter).second->IsOpen() && 0 == strcmp((*iter).second->GetPath(), path))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
break;      // found opened fd in mapping}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(fent.end() != iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// found}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
ent = (*iter).second;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else if(is_create)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// not found}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
string cache_path = "";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(!force_tmpfile && !FdManager::MakeCachePath(path, cache_path, true))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_ERR("failed to make cache path for object(%s).", path);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
return NULL;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
// make new obj}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
ent = new FdEntity(path, cache_path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(0 < cache_path.size())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// using cache}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
fent[string(path)] = ent;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// not using cache, so the key of fdentity is set not really existing path.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// (but not strictly unexisting path.)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// [NOTE]}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// The reason why this process here, please look at the definition of the}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// comments of NOCACHE_PATH_PREFIX_FORM symbol.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
//}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
string tmppath("");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
FdManager::MakeRandomTempPath(path, tmppath);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
fent[tmppath] = ent;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return NULL;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// open}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(0 != ent->Open(pmeta, size, time, no_fd_lock_wait))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return NULL;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return ent;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
FdEntity* FdManager::ExistOpen(const char* path, int existfd, bool ignore_existfd)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("[path=%s][fd=%d][ignore_existfd=%s]", SAFESTRPTR(path), existfd, ignore_existfd ? "true" : "false");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
// search by real path}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
FdEntity* ent = Open(path, NULL, -1, -1, false, false);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!ent && (ignore_existfd || (-1 != existfd)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// search from all fdentity because of not using cache.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
AutoLock auto_lock(&FdManager::fd_manager_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
for(fdent_map_t::iterator iter = fent.begin(); iter != fent.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if((*iter).second && (*iter).second->IsOpen() && (ignore_existfd || ((*iter).second->GetFd() == existfd)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// found opened fd in map}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
if(0 == strcmp((*iter).second->GetPath(), path))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
ent = (*iter).second;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
ent->Dup();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
// found fd, but it is used another file(file descriptor is recycled)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
// so returns NULL.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
break;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return ent;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
void FdManager::Rename(const std::string &from, const std::string &to)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&FdManager::fd_manager_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
fdent_map_t::iterator iter = fent.find(from);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(fent.end() != iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// found}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_DBG("[from=%s][to=%s]", from.c_str(), to.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
FdEntity* ent = (*iter).second;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
fent.erase(iter);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
ent->SetPath(to);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
fent[to] = ent;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdManager::Close(FdEntity* ent)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_DBG("[ent->file=%s][ent->fd=%d]", ent ? ent->GetPath() : "", ent ? ent->GetFd() : -1);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!ent)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;  // returns success}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&FdManager::fd_manager_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(fdent_map_t::iterator iter = fent.begin(); iter != fent.end(); ++iter)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if((*iter).second == ent)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
ent->Close();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(!ent->IsOpen())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// remove found entity from map.}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
fent.erase(iter++);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
// check another key name for entity value to be on the safe side}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
for(; iter != fent.end(); )\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
if((*iter).second == ent)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
            }{\rtlch \ltrch\loch
fent.erase(iter++);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
            }{\rtlch \ltrch\loch
++iter;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
          }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
delete ent;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdManager::ChangeEntityToTempPath(FdEntity* ent, const char* path)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&FdManager::fd_manager_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(fdent_map_t::iterator iter = fent.begin(); iter != fent.end(); )\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if((*iter).second == ent)\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
fent.erase(iter++);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
string tmppath("");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
FdManager::MakeRandomTempPath(path, tmppath);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
fent[tmppath] = ent;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
++iter;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
void FdManager::CleanupCacheDir()}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
S3FS_PRN_INFO("cache cleanup requested");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(!FdManager::IsCacheDir())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock_no_wait(&FdManager::cache_cleanup_lock, true);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(auto_lock_no_wait.isLockAcquired())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_INFO("cache cleanup started");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
CleanupCacheDirInternal("");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_INFO("cache cleanup ended");}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
// wait for other thread to finish cache cleanup}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
AutoLock auto_lock(&FdManager::cache_cleanup_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
void FdManager::CleanupCacheDirInternal(const std::string &path)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
DIR*           dp;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
struct dirent* dent;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
std::string    abs_path = cache_dir + "/" + bucket + path;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(NULL == (dp = opendir(abs_path.c_str())))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
S3FS_PRN_ERR("could not open cache dir(%s) - errno(%d)", abs_path.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
for(dent = readdir(dp); dent; dent = readdir(dp))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 == strcmp(dent->d_name, "..") || 0 == strcmp(dent->d_name, "."))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
continue;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
string   fullpath = abs_path;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
fullpath         += "/";}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
fullpath         += dent->d_name;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
struct stat st;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(0 != lstat(fullpath.c_str(), &st))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
S3FS_PRN_ERR("could not get stats of file(%s) - errno(%d)", fullpath.c_str(), errno);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
closedir(dp);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
return;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
string next_path = path + "/" + dent->d_name;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
if(S_ISDIR(st.st_mode))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
CleanupCacheDirInternal(next_path);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
FdEntity* ent;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(NULL == (ent = FdManager::get()->Open(next_path.c_str(), NULL, -1, -1, false, true, true)))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_DBG("skipping locked file: %s", next_path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
continue;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
if(ent->IsMultiOpened())\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_DBG("skipping opened file: %s", next_path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}else\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
ent->CleanupCache();}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
        }{\rtlch \ltrch\loch
S3FS_PRN_DBG("cleaned up: %s", next_path.c_str());}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
      }{\rtlch \ltrch\loch
Close(ent);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
closedir(dp);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
bool FdManager::ReserveDiskSpace(size_t size)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&FdManager::reserved_diskspace_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
if(IsSafeDiskSpace(NULL, size))\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
free_disk_space += size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
    }{\rtlch \ltrch\loch
return true;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
return false;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
void FdManager::FreeReservedDiskSpace(size_t size)}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\{}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
AutoLock auto_lock(&FdManager::reserved_diskspace_lock);}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch
  }{\rtlch \ltrch\loch
free_disk_space -= size;}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
\}}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20\rtlch \ltrch\loch

\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
/*}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
* Local variables:}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
* tab-width: 4}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
* c-basic-offset: 4}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
* End:}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
* vim600: noet sw=4 ts=4 fdm=marker}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
* vim<600: noet sw=4 ts=4}
\par \pard\plain \s20\sb0\sa0\dbch\af7\dbch\af5\afs20\loch\f5\fs20{\rtlch \ltrch\loch
*/}
\par }